package com.github.prometheus.votar.protocol;

import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.Validate;

import com.github.prometheus.votar.protocol.Protocol.DataType;

/** Reads information from the data stream generated by VOT.AR machines
 * according to the following specification: http://justpaste.it/lw65
 */
public class ProtocolReader extends Reader {

  /** Buffer to read data from memory. */
  private final ByteBuffer buffer = ByteBuffer
      .allocate(Protocol.BLOCKS * Protocol.BLOCK_SIZE);

  /** Input data, never null. */
  private final InputStream input;

  /** Creates a new protocol reader and reads data from the specified input
   * stream.
   * @param input Stream to read data. Cannot be null.
   */
  public ProtocolReader(InputStream input) {
    Validate.notNull(input, "The input cannot be null.");
    try {
      buffer.order(ByteOrder.BIG_ENDIAN);
      buffer.put(IOUtils.toByteArray(input));
    } catch (IOException cause) {
      throw new RuntimeException("Cannot read input data", cause);
    }

    this.input = input;
  }

  /** Reads the custom data into a char array.
   * <p>{@inheritDoc}</p>
   */
  @Override
  public int read(char[] cbuf, int off, int len) throws IOException {
    Validate.isTrue((off + len) < Protocol.DATA_BLOCKS * Protocol.BLOCK_SIZE,
        "Invalid offset or length.");

    for (int i = off; i < off + len; i++) {
      cbuf[off] = buffer.getChar(off);
    }

    return len;
  }

  public DataType getDataType() {
    return DataType.fromValue(buffer.get(Protocol.OFFSET_DATA_TYPE));
  }

  /** Returns the tag custom data.
   * @return The custom data, never null.
   */
  public byte[] getData() {
    int length = buffer.getShort(Protocol.OFFSET_DATA_LENGTH);
    byte[] data = new byte[length];

    buffer.position(Protocol.OFFSET_DATA);
    buffer.get(data);

    return data;
  }

  /** Returns the tag custom data as String.
   * @return The custom data, never null.
   */
  public String getDataAsString() {
    return new String(getData());
  }

  /** Returns the calculated CRC for the data.
   * @return a valid CRC.
   */
  public long getCrc() {
    return buffer.getLong(Protocol.OFFSET_CRC);
  }

  /** Closes the input stream.
   */
  @Override
  public void close() throws IOException {
    input.close();
  }
}
